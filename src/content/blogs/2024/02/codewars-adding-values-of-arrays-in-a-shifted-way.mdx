---
title:
pubDate: 2024-02-03
description:
category: coden
tags:
series: code challenges
vgWortCode: 181d490a284a4b1980728ac7b41bc2f9

codeChallengeData:
  platform: codewars
  id: 57c7231c484cf9e6ac000090
  language: TypeScript
---

## Inhalt

1. [Die Fakten](#)
1. [Beschreibung](#)
1. [L√∂sung](#)
   1. [Pseudo-Code](#)
   1. [Code](#)
1. [Feedback](#)

---

## Die Fakten:

|                |                                                                                                                                            |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| **Plattform:** | <ExternalLink href={baseURLs[codeChallengeData['platform']]}>{domains[codeChallengeData['platform']]}</ExternalLink>                       |
| **Name:**      | <ExternalLink href={`${codeChallenge[codeChallengeData['platform']].challenge.url}/${codeChallengeData.id}`}>{apiData.name}</ExternalLink> |
| **Level**:     | {apiData.level}                                                                                                                            |
| **Sprache**:   | {codeChallengeData.language}                                                                                                               |

## Beschreibung:

<FetchedMarkdown>{apiData.description}</FetchedMarkdown>

Quelle: <ExternalLink href={baseURLs[codeChallengeData['platform']]}>{domains[codeChallengeData['platform']]}</ExternalLink>

## L√∂sung

### Pseudo-Code

Es gibt wie immer viele Varianten, hier ist eine meiner.

Erst die L√∂sungsschritte in Pseudo-Code. Los geht‚Äôs:

<Accordion>
**L√∂sungsschritte**

<Accordion>
Schritt 1

Zuerst m√ºssen wir rauskriegen, wie lang unser Ergebnis-Array sein wird

</Accordion>
<Accordion>
Schritt 2

Dann k√∂nnen wir dieses schon mal erstellen

</Accordion>
<Accordion>
Schritt 3

Danach k√∂nnen wir loopen

</Accordion>
<Accordion>
Schritt 4

Wir werden 2 Loops brauchen

</Accordion>
<Accordion>
Schritt 5

Der √§u√üere so lange, wie unser Ergebnis-Array lang ist

</Accordion>
<Accordion>
Schritt 6

Der innere so lange, wie die Anzahl der Unter-Arrays

</Accordion>
<Accordion>
Schritt 7

Dann k√∂nnen wir die Zahlen untereinander zusammenrechnen

</Accordion>
<Accordion>
Schritt 8

Und dann im Ergebnis-Array speichern

</Accordion>

</Accordion>

### Code

Geil. √úbersetzen wir unseren Pseudo-Code in {codeChallengeData.language}:

<Accordion>
**L√∂sungsschritte**

<Accordion>
Meine erste Zeile (ich fand `arrayOfArrays` etwas ungl√ºcklich und habe es in `arrays` umbenannt):

```ts
export function addingShifted(arrays: number[][], shift: number): number[] {
```

</Accordion>
<Accordion>
Die L√§nge des Ergebnis-Arrays berechnen:

```ts
const subArrLength = arrays[0].length;
const resultLength = subArrLength + (arrays.length - 1) * shift;
```

Daf√ºr kucken wir zuerst wie lang ein inneres Array ist. An diese L√§nge h√§ngen wir so oft `shift` dran, wie wir innere Arrays haben - aber ein Mal weniger. OK?! Jut.

Wenn wir also einen `shift` von `3` haben und unser `array` `2` innere Arrays hat, die jeweils `6` Elemente haben, ist die L√§nge des Ergebnis-Arrays:

`6` + (`2` - `1`) \* `3` = `9`

Bei `3` inneren Arrays:

`6` + (`3` - `1`) \* `3` = `12`

</Accordion>
<Accordion>
Jetzt erstellen wir unser Ergebnis-Array:

```ts
const sums = Array(resultLength).fill(0);
```

Das Array hat die L√§nge `resultLength` und wir f√ºllen es mit Nullen.

</Accordion>
<Accordion>
Jetzt der erste, der √§u√üere Loop:

```ts
  for (let i = 0; i < resultLength; i++) {
```

Hier iterieren wir horizontal, also von links nach rechts, durch unser Ergebnis-Array.

</Accordion>
<Accordion>
Und der zweite, der innere Loop:

```ts
    for (let j = 0; j < arrays.length; j++) {
```

Hier iterieren wir vertikal, also von oben nach unten, durch das Input-Array. D.h., von einem inneren Array zum n√§chsten.

</Accordion>
<Accordion>
Jetzt checken wir das jeweilige Element im aktuellen inneren Array:

```ts
const k = i - shift * j;
```

Daf√ºr bauen wir uns zun√§chst den Index des aktuellen Elements im aktuellen inneren Array.

Beispiel: `0` - `3` \* `1` = `-3`

</Accordion>
<Accordion>
Und addieren den Wert des Elements an die aktuelle Stelle in unserem Ergebnis-Array:

```ts
      sums[i] += arrays[j][k] || 0;
    }
  }
```

Im obigen Beispiel befindet sich unter der ersten Stelle (das Element mit Index `0`) des ersten Arrays das `-3.` Element des zweiten Arrays. Das gibt es nat√ºrlich nicht. Darum addieren wir in diesem Fall n√ºscht. N√ºscht ist `0`. <ExternalLink href={docs.operators.logicalOr}>Logisch, oder?!</ExternalLink>

</Accordion>
<Accordion>
Nach den Loops noch unsere Summen zur√ºckgeben: üêùüí§

```ts
  return sums;
}
```

</Accordion>
<Accordion>

Voil√°! üí™

[Fragen?](#feedback)

</Accordion>
</Accordion>

<Accordion>
**Komplettl√∂sung**

```ts
export function addingShifted(arrays: number[][], shift: number): number[] {
  const subArrLength = arrays[0].length;
  const resultLength = subArrLength + (arrays.length - 1) * shift;

  const sums = Array(resultLength).fill(0);

  for (let i = 0; i < resultLength; i++) {
    for (let j = 0; j < arrays.length; j++) {
      const k = i - shift * j;
      sums[i] += arrays[j][k] || 0;
    }
  }

  return sums;
}
```

</Accordion>

## Feedback

<Accordion>
**Schreib mir!**

<SocialLinks
  emailSubject={`Frage zu ${apiData.platform} "${apiData.name}" (${codeChallengeData.language})`}
/>

</Accordion>
