---
title:
pubDate: 2024-02-28
description:
category: coden
tags:
series: code challenges
vgWortCode: c46b7eceb0de4935977c7ad0500657bc

codeChallengeData:
  platform: codewars
  id: 5539fecef69c483c5a000015
  language: TypeScript
---

## Inhalt

1. [Die Fakten](#)
1. [Beschreibung](#)
1. [L√∂sung](#)
   1. [Pseudo-Code](#)
   1. [Code](#)
1. [Feedback](#)

---

## Die Fakten:

|                |                                                                                                                                            |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| **Plattform:** | <ExternalLink href={baseURLs[codeChallengeData['platform']]}>{domains[codeChallengeData['platform']]}</ExternalLink>                       |
| **Name:**      | <ExternalLink href={`${codeChallenge[codeChallengeData['platform']].challenge.url}/${codeChallengeData.id}`}>{apiData.name}</ExternalLink> |
| **Level**:     | {apiData.level}                                                                                                                            |
| **Sprache**:   | {codeChallengeData.language}                                                                                                               |

## Beschreibung:

<FetchedMarkdown>{apiData.description}</FetchedMarkdown>

Quelle: <ExternalLink href={baseURLs[codeChallengeData['platform']]}>{domains[codeChallengeData['platform']]}</ExternalLink>

## L√∂sung

### Pseudo-Code

Wie immer gibt's reichlich Varianten, hier ist eine meiner.

Erst die L√∂sungsschritte in Pseudo-Code. Los geht‚Äôs:

<Accordion>
**L√∂sungsschritte**

<Accordion>
Schritt 1

Als erstes macht es Sinn eine Helfer-Funktion zu basteln, die (effektiv) checkt, ob eine Zahl eine Primzahl ist.

</Accordion>
<Accordion>
Schritt 2

Dazu k√∂nnen wir die Trial-Devision bzw. [Probedivision](https://www.wikiwand.com/de/Probedivision) anwenden.

</Accordion>
<Accordion>
Schritt 3

Dann k√∂nnen wir in unserer Hauptfunktion von `start` bis `stop` loopen.

</Accordion>
<Accordion>
Schritt 4

Wenn die aktuelle Zahl eine Primzahl ist, pr√ºfen wir, ob sie auch r√ºckw√§rts eine Primzahl ist.

</Accordion>
<Accordion>
Schritt 5

Au√üerdem soll es r√ºckw√§rts nicht die gleiche Zahl wie vorw√§rts sein.

</Accordion>
<Accordion>
Schritt 6

Wenn beides zutrifft, f√ºgen wir die Zahl zu einem Array hinzu.

</Accordion>
</Accordion>

### Code

Geil. √úbersetzen wir unseren Pseudo-Code in {codeChallengeData.language}:

<Accordion>
**L√∂sungsschritte**

<Accordion>
Die erste Zeile meiner Helfer-Funktion:

```ts
function isPrime(num: number): boolean {
```

</Accordion>
<Accordion>

Als erstes schlie√üen wir alles aus, was kleiner als 1 ist:

```ts
if (num <= 1) return false;
```

</Accordion>
<Accordion>

Jetzt loopen wir (effizient) bis zur Wurzel unserer zu pr√ºfenden Zahl:

```ts
  for (let i = 2; i <= Math.sqrt(num); i++) {
```

Siehe Trial Division, bzw. [Probedivision](https://www.wikiwand.com/de/Probedivision).

</Accordion>
<Accordion>

Wenn unsere Zahl durch eine der aktuellen Zahlen teilbar ist, ist es keine Primzahl:

```ts
    if (num % i === 0) return false;
  }
```

Und wir k√∂nnen den Loop (und die Funktion) mit `return` sofort beenden.

</Accordion>
<Accordion>

Ansonsten schon:

```ts
  return true;
}
```

Das war unserer Helferlein. Weiter geht's mit der Hauptfunktion.

</Accordion>
<Accordion>

Die erste Zeile meiner Hauptfunktion:

```ts
export function backwardsPrime(start: number, stop: number): number[] {
```

</Accordion>
<Accordion>

Ich erstelle mir das Array f√ºr die gesammelten R√ºckw√§rts-Primzahlen:

```ts
const backwardsPrimes: number[] = [];
```

</Accordion>
<Accordion>

Jetzt der Loop:

```ts
  for (let i = start; i <= stop; i++) {
```

</Accordion>
<Accordion>

Wir pr√ºfen jede Zahl, ob es eine Primzahl ist:

```ts
    if (isPrime(i)) {
```

Dabei hilft uns unser Helferlein von oben.

</Accordion>
<Accordion>

Wenn es eine Primzahl ist, k√∂nnen wir sie umdrehen:

```ts
const revNum = Number([...String(i)].reverse().join(""));
```

Wir spreaden die Ziffern der String-Zahl in ein Array, das wir dann umdrehen, wieder zusammenf√ºgen und zur√ºck in eine Zahl umwandeln.

</Accordion>
<Accordion>

Dann pr√ºfen wir, ob die R√ºckw√§rts-Zahl auch eine Primzahl und nicht die gleiche Zahl wie vorw√§rts ist:

```ts
      if (isPrime(revNum) && revNum !== i) backwardsPrimes.push(i);
    }
  }
```

Wenn das passt, f√ºgen wir die Zahl zu unserem Ergebnis-Array hinzu.

</Accordion>
<Accordion>

Nach dem Loop nur noch das Ergebnis zur√ºckgeben:

```ts
  return backwardsPrimes;
}
```

</Accordion>
<Accordion>

Fertsch! üí™

[Fragen?](#feedback)

</Accordion>
</Accordion>

<Accordion>
**Komplettl√∂sung**

```ts
export function backwardsPrime(start: number, stop: number): number[] {
  const backwardsPrimes: number[] = [];

  for (let i = start; i <= stop; i++) {
    if (isPrime(i)) {
      const revNum = Number([...String(i)].reverse().join(""));
      if (isPrime(revNum) && revNum !== i) backwardsPrimes.push(i);
    }
  }

  return backwardsPrimes;
}

function isPrime(num: number): boolean {
  if (num <= 1) return false;

  for (let i = 2; i <= Math.sqrt(num); i++) {
    if (num % i === 0) return false;
  }

  return true;
}
```

</Accordion>

## Feedback

<Accordion>
**Schreib mir!**

<SocialLinks
  emailSubject={`Frage zu ${apiData.platform} "${apiData.name}" (${codeChallengeData.language})`}
/>

</Accordion>
