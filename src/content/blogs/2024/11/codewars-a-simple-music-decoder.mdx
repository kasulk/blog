---
title:
pubDate: 2024-11-06
description:
category: coden
tags:
series: code challenges
vgWortCode: 12d7b614e32a47928dcb3223590b1ce9

codeChallengeData:
  platform: codewars
  id: 58de42bab4b74c214d0000e2
  language: TypeScript
---

## Inhalt

1. [Die Fakten](#)
1. [Beschreibung](#)
1. [L√∂sung](#)
   1. [Pseudo-Code](#)
   1. [Code](#)
1. [Feedback](#)

---

## Die Fakten:

|                |                                                                                                                                            |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| **Plattform:** | <ExternalLink href={baseURLs[codeChallengeData['platform']]}>{domains[codeChallengeData['platform']]}</ExternalLink>                       |
| **Name:**      | <ExternalLink href={`${codeChallenge[codeChallengeData['platform']].challenge.url}/${codeChallengeData.id}`}>{apiData.name}</ExternalLink> |
| **Level**:     | {apiData.level}                                                                                                                            |
| **Sprache**:   | {codeChallengeData.language}                                                                                                               |

## Beschreibung:

<FetchedMarkdown>{apiData.description}</FetchedMarkdown>

Quelle: <ExternalLink href={baseURLs[codeChallengeData['platform']]}>{domains[codeChallengeData['platform']]}</ExternalLink>

## L√∂sung

### Pseudo-Code

Wie immer gibt's reichlich Varianten, hier ist eine meiner.

Erst die L√∂sungsschritte in Pseudo-Code. Los geht‚Äôs:

<Accordion>
**L√∂sungsschritte**

<Accordion>
Schritt 1

Ich schlage vor, dass wir jede Range in einem Token in ein Array mit Zahlen aufl√∂sen.

</Accordion>
<Accordion>
Schritt 2

Daf√ºr macht es Sinn eine eigene Hilfsfunktion zu erstellen.

</Accordion>
<Accordion>
Schritt 3

Wenn wir der Hilfsfunktion das Intervall mit √ºbergeben, k√∂nnen wir sie f√ºr beide m√∂glichen Intervall-Tokens verwenden.

</Accordion>
<Accordion>
Schritt 4

In der Hilfsfunktion sollten wir dann als Erstes das `bis` also das `-` finden.

</Accordion>
<Accordion>
Schritt 5

Da eine Range auch bei negativen Zahlen starten und enden kann, k√∂nnen allerdings mehrere `-` enthalten sein.

</Accordion>
<Accordion>
Schritt 6

Eine M√∂glichkeit ist, das `-` zu finden, welches das erste `-` nach dem ersten Zeichen ist.

</Accordion>
<Accordion>
Schritt 7

Dann k√∂nnen wir Start und Ende der Range bestimmen.

</Accordion>
<Accordion>
Schritt 8

Wenn der Anfang der Range kleiner als das Ende ist, m√ºssen wir vorw√§rts z√§hlen, ansonsten r√ºckw√§rts.

</Accordion>
<Accordion>
Schritt 9

Jetzt k√∂nnen wir ein Array mit den Zahlen von Anfang bis Ende mit dem richtigen Intervall bef√ºllen.

</Accordion>
<Accordion>
Schritt 10

Dann k√∂nnen wir uns um die Hauptfunktion k√ºmmern.

</Accordion>
<Accordion>
Schritt 11

Zuerst loopen wir durch die einzelnen Tokens.

</Accordion>
<Accordion>
Schritt 12

Da wir alle Ranges und Tokens mit `*` in Arrays aufl√∂sen, loopen wir hier am besten direkt mit <ExternalLink href={docs.array.flatMap}>`.flatMap()`</ExternalLink>!

</Accordion>
<Accordion>
Schritt 13

Jetzt brauchen wir nur noch `3` Bedingungen.

</Accordion>
<Accordion>
Schritt 14

1. Wenn das aktuelle Token ein `*` enth√§lt, geben wir dem Array ein Array mit `x` Wiederholungen der Zahl zur√ºck.

</Accordion>
<Accordion>
Schritt 15

2. Wenn das aktuelle Token ein `/` enth√§lt, geben wir dem Array ein Array mit den Zahlen von-bis mit dem entsprechenden Intervall zur√ºck.

</Accordion>
<Accordion>
Schritt 16

3. Wenn das Token nur ein `-` enth√§lt, geben wir dem Array ein Array mit den Zahlen von-bis mit dem Intervall `1` zur√ºck.

</Accordion>
<Accordion>
Schritt 17

Ansonsten geben wir dem Array das Token als Zahl zur√ºck.

</Accordion>
<Accordion>
Schritt 18

Das Ganze noch zur√ºckgeben, fertig!

</Accordion>
</Accordion>

### Code

Geil. √úbersetzen wir unseren Pseudo-Code in {codeChallengeData.language}:

<Accordion>
**L√∂sungsschritte**

<Accordion>
Die erste Zeile meiner Hilfsfunktion:

```ts
function createArrayFromRange(range: string, interval: number = 1): number[] {
```

Die Hilfsfunktion bekommt den Range-String und ein optionales Intervall. Wenn kein Intervall √ºbergeben wird, setzen wir es standardm√§√üig auf `1`.

</Accordion>
<Accordion>

Jetzt suchen wir die Position des richtigen `-`:

```ts
const dashPosition = range.indexOf("-", 1);
```

Da auch an der ersten Stelle ein `-` stehen kann, suchen wir den Index des ersten `-` nach dem ersten Element. Daf√ºr steht die `1` im zweiten Argument von <ExternalLink href={docs.string.indexOf}>`.indexOf()`</ExternalLink>.

</Accordion>
<Accordion>

Mit der `dashPosition` k√∂nnen wir dann Anfang und Ende der Range definieren:

```ts
const start = Number(range.slice(0, dashPosition));
const end = Number(range.slice(dashPosition + 1));
```

</Accordion>
<Accordion>

Jetzt k√∂nnen wir die L√§nge der Range definieren:

```ts
const arrLen = Math.abs(start - end) / interval + 1;
```

</Accordion>
<Accordion>

Au√üerdem m√ºssen wir ermitteln in welche Richtung die Range geht:

```ts
const signedInterval = start < end ? +interval : -interval;
```

</Accordion>
<Accordion>

Wenn wir beides haben k√∂nnen wir das Array erstellen:

```ts
  return Array(arrLen)
    .fill(0)
    .map((_, i) => start + i * signedInterval);
}
```

Wir erstellen ein leeres Array mit der oben ermittelten L√§nge. Das f√ºllen wir zuerst mit Nullen und anschlie√üend mit den richtigen Zahlen der Range.

Das Ganze noch zur√ºckgeben und fertig ist die Hilfsfunktion um Ranges in Arrays umzuwandeln. Weiter geht‚Äôs mit der Hauptfunktion!

</Accordion>
<Accordion>

Hier die erste Zeile meiner Hauptfunktion:

```ts
export function uncompress(music: string): number[] {
```

</Accordion>
<Accordion>

Als Erstes der Loop durch die Tokens:

```ts
  return music.split(",").flatMap((token) => {
```

Wie oben erw√§hnt, eignet sich hier wunderbar <ExternalLink href={docs.array.flatMap}>`.flatMap()`</ExternalLink>, damit wir die ganzen Subarrays in einem Rutsch mit aufl√∂sen k√∂nnen.

Unser `return` k√∂nnen wir bereits hier mit hinsetzen.

</Accordion>
<Accordion>

Dann die erste Bedingung:

```ts
if (token.includes("*")) {
  const [num, count] = token.split("*").map(Number);
  return Array(count).fill(num);
}
```

</Accordion>
<Accordion>

Jetzt die zweite Bedingung:

```ts
if (token.includes("/")) {
  const [range, interval] = token.split("/");
  return createArrayFromRange(range, Number(interval));
}
```

Hier kommt zum ersten Mal unsere Hilfsfunktion zu Einsatz. Geil!

</Accordion>
<Accordion>

Dann die dritte Bedingung:

```ts
if (token.includes("-")) return createArrayFromRange(token);
```

Ich spare mir hier das Gewurschtel mit wilden `if...else`-Konstrunktionen. Darum ist es wichtig, dass der Check (f√ºr Ranges) mit dem `-` _nach_ dem Check (f√ºr Ranges) mit dem `/` kommt!

</Accordion><Accordion>

In allen √ºbrigen F√§llen ist das aktuelle Token eine Zahl. Die geben wir einfach als solche zur√ºck:

```ts
    return Number(token);
  });
}
```

</Accordion>
<Accordion>

Voil√°! üí™

Sch√∂nes Kata! Bisschen schwierig zu erkl√§ren... Aber ich hoffe es hat Dir trotzdem Spa√ü gemacht! üòâ

[Fragen?](#feedback)

</Accordion>
</Accordion>

<Accordion>
**Komplettl√∂sung**

```ts
export function uncompress(music: string): number[] {
  return music.split(",").flatMap((token) => {
    if (token.includes("*")) {
      const [num, count] = token.split("*").map(Number);
      return Array(count).fill(num);
    }

    if (token.includes("/")) {
      const [range, interval] = token.split("/");
      return createArrayFromRange(range, Number(interval));
    }

    if (token.includes("-")) return createArrayFromRange(token);

    return Number(token);
  });
}

function createArrayFromRange(range: string, interval: number = 1): number[] {
  const dashPosition = range.indexOf("-", 1);
  const start = Number(range.slice(0, dashPosition));
  const end = Number(range.slice(dashPosition + 1));
  const arrLen = Math.abs(start - end) / interval + 1;
  const signedInterval = start < end ? +interval : -interval;
  return Array(arrLen)
    .fill(0)
    .map((_, i) => start + i * signedInterval);
}
```

</Accordion>

## Feedback

<Accordion>
**Schreib mir!**

<SocialLinks
  emailSubject={`Frage zu ${apiData.platform} "${apiData.name}" (${codeChallengeData.language})`}
/>

</Accordion>
