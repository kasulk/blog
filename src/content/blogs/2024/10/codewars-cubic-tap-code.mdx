---
title:
pubDate: 2024-10-10
description:
category: coden
tags:
series: code challenges
vgWortCode: 0d1f90ba7626491a86da9727dfd99f58

codeChallengeData:
  platform: codewars
  id: 62d1eb93e5994c003156b2ae
  language: TypeScript
---

## Inhalt

1. [Die Fakten](#)
1. [Beschreibung](#)
1. [L√∂sung](#)
   1. [Pseudo-Code](#)
   1. [Code](#)
1. [Feedback](#)

---

## Die Fakten:

|                |                                                                                                                                            |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| **Plattform:** | <ExternalLink href={baseURLs[codeChallengeData['platform']]}>{domains[codeChallengeData['platform']]}</ExternalLink>                       |
| **Name:**      | <ExternalLink href={`${codeChallenge[codeChallengeData['platform']].challenge.url}/${codeChallengeData.id}`}>{apiData.name}</ExternalLink> |
| **Level**:     | {apiData.level}                                                                                                                            |
| **Sprache**:   | {codeChallengeData.language}                                                                                                               |

## Beschreibung:

<FetchedMarkdown>{apiData.description}</FetchedMarkdown>

Quelle: <ExternalLink href={baseURLs[codeChallengeData['platform']]}>{domains[codeChallengeData['platform']]}</ExternalLink>

## L√∂sung

### Pseudo-Code

Wie immer gibt's reichlich Varianten, hier ist eine meiner.

Erst die L√∂sungsschritte in Pseudo-Code. Los geht‚Äôs:

<Accordion>
**L√∂sungsschritte**

<Accordion>
Schritt 1

Zuerst k√∂nnen wir uns ein Objekt erstellen, das alle Buchstaben auf den Tap-Code umschl√ºsselt.

</Accordion>
<Accordion>
Schritt 2

F√ºr die `encode`-Funktion k√∂nnen wir dann einfach den Buchstaben in unserem Objekt nachschlagen und ausgeben.

</Accordion>
<Accordion>
Schritt 3

F√ºr die `decode`-Funktion k√∂nnen wir unser Objekt mit Buchstaben und Tap-Codes einfach umdrehen. D.h., `keys` und `values` vertauschen.

</Accordion>
<Accordion>
Schritt 4

Dann m√ºssen wir aus dem Input-String Dreier-Gruppen erstellen.

</Accordion>
<Accordion>
Schritt 5

Diese Dreier-Gruppen k√∂nnen wir dann im umgedrehten Objekt nachschlagen.

</Accordion>
<Accordion>
Schritt 6

Den jeweils erhaltenen Buchstaben nur noch ans Ergebnis anh√§ngen.

</Accordion>
<Accordion>
Schritt 7

Am Ende alles ausgeben - fertig!

</Accordion>
</Accordion>

### Code

Geil. √úbersetzen wir unseren Pseudo-Code in {codeChallengeData.language}:

<Accordion>
**L√∂sungsschritte**

<Accordion>
Zuerst mein Objekt mit Buchstaben und Tap-Codes:

```ts
const map: { [key: string]: string } = {
  A: ". . .",
  B: ".. . .",
  C: "... . .",
  D: ". .. .",
  E: ".. .. .",
  F: "... .. .",
  G: ". ... .",
  H: ".. ... .",
  I: "... ... .",
  J: ". . ..",
  K: ".. . ..",
  L: "... . ..",
  M: ". .. ..",
  N: ".. .. ..",
  O: "... .. ..",
  P: ". ... ..",
  Q: ".. ... ..",
  R: "... ... ..",
  S: ". . ...",
  T: ".. . ...",
  U: "... . ...",
  V: ". .. ...",
  W: ".. .. ...",
  X: "... .. ...",
  Y: ". ... ...",
  Z: ".. ... ...",
  " ": "... ... ...",
};
```

</Accordion>
<Accordion>

Als n√§chstes speichere ich mir schon mal das umgedrehte Objekt in einer Variablen:

```ts
const reversedMap = Object.fromEntries(
  Object.entries(map).map(([key, value]) => [value, key]),
);
```

<ExternalLink href={docs.object.entries}>`Object.entries()`</ExternalLink> erstellt
ein Array aus einem Objekt durch das wir dann mappen k√∂nnen. Das Array habe ich
direkt deconstructed. Das macht es sch√∂n kurz und lesbar.

<ExternalLink href={docs.object.fromEntries}>`Object.fromEntries()`</ExternalLink> wiederum erstellt ein Objekt aus einem Array.

Der Inhalt des umgedrehten Objekts sieht dann also so aus:

```ts
{
  '. . .': 'A',
  '.. . .': 'B',
  '... . .': 'C',
  '. .. .': 'D',
  '.. .. .': 'E',
  '... .. .': 'F',
  '. ... .': 'G',
  '.. ... .': 'H',
  '... ... .': 'I',
  '. . ..': 'J',
  '.. . ..': 'K',
  '... . ..': 'L',
  '. .. ..': 'M',
  '.. .. ..': 'N',
  '... .. ..': 'O',
  '. ... ..': 'P',
  '.. ... ..': 'Q',
  '... ... ..': 'R',
  '. . ...': 'S',
  '.. . ...': 'T',
  '... . ...': 'U',
  '. .. ...': 'V',
  '.. .. ...': 'W',
  '... .. ...': 'X',
  '. ... ...': 'Y',
  '.. ... ...': 'Z',
  '... ... ...': ' '
}
```

Dann k√∂nnen wir uns an die `encode`-Funktion machen.

</Accordion>
<Accordion>

Die erste Zeile meiner `encode`-Funktion:

```ts
export function encode(str: string): string {
```

</Accordion>
<Accordion>

Zuerst wandeln wir den Input-String in ein Array um:

```ts
  return str.split("");
```

Ich behaupte, wir k√∂nnen hier chainen. Darum setze ich schon mal das `return` davor.

</Accordion>
<Accordion>

Dann der Loop f√ºr das Nachschlagen der Buchstaben bzw. Tap-Codes:

```ts
    .map((char) => map[char])
```

Da wir f√ºr jeden Buchstaben genau einen Tap-Code zur√ºckbekommen wollen, eignet sich hier wunderbar <ExternalLink href={docs.array.map}>`.map()`</ExternalLink>.

</Accordion>
<Accordion>

Zum Schluss nur noch das Array wieder zur√ºck in einen String umwandeln:

```ts
    .join(" ");
}
```

Das war schon die `encode`-Funktion. Weiter geht‚Äôs mit der `decode`-Funktion.

</Accordion>
<Accordion>

Die erste Zeile meiner `decode`-Funktion:

```ts
export function decode(str: string): string {
```

</Accordion>
<Accordion>

Hier brauchen wir als Erstes eine Variable in der wir alle entschl√ºsselten Buchstaben speichern:

```ts
  const chars: string[] = [];
```

</Accordion>
<Accordion>

Au√üerdem erstelle ich mir noch eine Variable in der ich die Dreier-Gruppen zusammenstelle:

```ts
  let triple: string[] = [];
```

</Accordion>
<Accordion>

Dann der Loop durch Punkt-Gruppen:

```ts
  str.split(" ").forEach((dots, i) => {
```

</Accordion>
<Accordion>

Jede Punkt-Gruppe h√§ngen wir an unsere Variable f√ºr die Dreier-Gruppen:

```ts
    triple.push(dots);
```

</Accordion>
<Accordion>

Dann pr√ºfen wir, ob die Dreier-Gruppe komplett ist, also `3` Punkt-Gruppen enth√§lt:

```ts
    if (i % 3 === 2) {
```

Das mache ich hier √ºber den Index. Es ginge aber nat√ºrlich auch √ºber die Array-L√§nge üòâ

</Accordion>
<Accordion>

Wenn die Dreier-Gruppe komplett ist, schlagen wir sie in unserem umgedrehten Objekt (`reversedMap`) nach:

```ts
      const charDots = triple.join(" ");
      const char = reversedMap[charDots];
```

</Accordion>
<Accordion>

Den erhaltenen Buchstaben h√§ngen wir dann an unser `chars`-Array:

```ts
      chars.push(char);
      triple = [];
    }
  });
```

Danach setzen wir noch das Array f√ºr die aktuelle Dreier-Gruppe zur√ºck, damit wir die n√§chste Dreier-Gruppe darin sammeln k√∂nnen.

</Accordion>
<Accordion>

Zum Schluss nur noch das `chars`-Array als String zur√ºckgeben:

```ts
  return chars.join("");
}
```

</Accordion>
<Accordion>

Voil√°! üí™

[Fragen?](#feedback)

</Accordion>
</Accordion>

<Accordion>
**Komplettl√∂sung**

```ts
const map: { [key: string]: string } = {
  A: ". . .",
  B: ".. . .",
  C: "... . .",
  D: ". .. .",
  E: ".. .. .",
  F: "... .. .",
  G: ". ... .",
  H: ".. ... .",
  I: "... ... .",
  J: ". . ..",
  K: ".. . ..",
  L: "... . ..",
  M: ". .. ..",
  N: ".. .. ..",
  O: "... .. ..",
  P: ". ... ..",
  Q: ".. ... ..",
  R: "... ... ..",
  S: ". . ...",
  T: ".. . ...",
  U: "... . ...",
  V: ". .. ...",
  W: ".. .. ...",
  X: "... .. ...",
  Y: ". ... ...",
  Z: ".. ... ...",
  " ": "... ... ...",
};

const reversedMap = Object.fromEntries(
  Object.entries(map).map(([key, value]) => [value, key]),
);

export function encode(str: string): string {
  return str
    .split("")
    .map((char) => map[char])
    .join(" ");
}

export function decode(str: string): string {
  const chars: string[] = [];
  let triple: string[] = [];

  str.split(" ").forEach((dots, i) => {
    triple.push(dots);

    if (i % 3 === 2) {
      const charDots = triple.join(" ");
      const char = reversedMap[charDots];
      chars.push(char);
      triple = [];
    }
  });

  return chars.join("");
}
```

</Accordion>

## Feedback

<Accordion>
**Schreib mir!**

<SocialLinks
  emailSubject={`Frage zu ${apiData.platform} "${apiData.name}" (${codeChallengeData.language})`}
/>

</Accordion>
