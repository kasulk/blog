---
title:
pubDate: 2024-07-31
description:
category: coden
tags:
series: code challenges
vgWortCode: fd25f4b894eb4b82be8fdc378502583c

codeChallengeData:
  platform: codewars
  id: 51ba717bb08c1cd60f00002f
  language: JavaScript
---

## Inhalt

1. [Die Fakten](#)
1. [Beschreibung](#)
1. [L√∂sung](#)
   1. [Pseudo-Code](#)
   1. [Code](#)
1. [Feedback](#)

---

## Die Fakten:

|                |                                                                                                                                            |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| **Plattform:** | <ExternalLink href={baseURLs[codeChallengeData['platform']]}>{domains[codeChallengeData['platform']]}</ExternalLink>                       |
| **Name:**      | <ExternalLink href={`${codeChallenge[codeChallengeData['platform']].challenge.url}/${codeChallengeData.id}`}>{apiData.name}</ExternalLink> |
| **Level**:     | {apiData.level}                                                                                                                            |
| **Sprache**:   | {codeChallengeData.language}                                                                                                               |

## Beschreibung:

<FetchedMarkdown>{apiData.description}</FetchedMarkdown>

Quelle: <ExternalLink href={baseURLs[codeChallengeData['platform']]}>{domains[codeChallengeData['platform']]}</ExternalLink>

## L√∂sung

### Pseudo-Code

Es gibt wie immer viele Varianten, hier ist eine meiner.

Erst die L√∂sungsschritte in Pseudo-Code. Los geht‚Äôs:

<Accordion>
**L√∂sungsschritte**

<Accordion>
Schritt 1

Als Erstes brauchen wir 2 Variablen, genauer Arrays. Eine um unser Endergebnis zu speichern und eine zum Zwischenspeichern der aktuellen potentiellen Range

</Accordion>
<Accordion>
Schritt 2

Dann loopen wir durch die Zahlen des Input-Arrays

</Accordion>
<Accordion>
Schritt 3

In jeder Iteration berechnen wir den Abstand der aktuellen zur n√§chsten Zahl

</Accordion>
<Accordion>
Schritt 4

Wenn dieser Abstand `1` ist, k√∂nnen wir die aktuelle Zahl ruhigen Gewissens an unser Zwischenspeicher-Array h√§ngen

</Accordion>
<Accordion>
Schritt 5

Wenn der Abstand nicht `1` ist, pr√ºfen wir ob unser Zwischenspeicher-Array leer ist

</Accordion>
<Accordion>
Schritt 6

Wenn es nicht leer ist, haben wir gerade die letzte Zahl der aktuellen Range und h√§ngen sie noch ans Zwischenspeicher-Array an

</Accordion>
<Accordion>
Schritt 7

Dann pr√ºfen wir, ob die aktuelle Range im Zwischenspeicher-Array 3 oder mehr Zahlen beeinhaltet

</Accordion>
<Accordion>
Schritt 8

Wenn ja, k√∂nnen wir die erste und die letzte Zahl der aktuellen Range, getrennt mit einem Bindestrich an unser Endergebnis-Array h√§ngen

</Accordion>
<Accordion>
Schritt 9

Ansonsten h√§ngen wir nur die beiden Zahlen an, die im Zwischenspeicher-Array sind

</Accordion>
<Accordion>
Schritt 10

Nachdem wir eine Range hatten, d√ºrfen wir nicht vergessen, das Zwischenspeicher-Array wieder zu leeren

</Accordion><Accordion>
Schritt 11

Wenn der Abstand nicht `1` war und das Zwischenspeicher-Array aktuell leer ist, h√§ngen wir die Zahl wie sie ist an das Endergebnis-Array

</Accordion><Accordion>
Schritt 12

Nach dem Loop noch Endergebnis komma-getrennt ausgeben, fertig!

</Accordion>

</Accordion>

### Code

Geil. √úbersetzen wir unseren Pseudo-Code in {codeChallengeData.language}:

<Accordion>
**L√∂sungsschritte**

<Accordion>
Meine erste Zeile (ich habe `list` in `nums` umbenannt):
```js
function solution(nums) {
```

</Accordion>
<Accordion>
Zuerst unsere beiden Arrays f√ºr Endergebnis und zum Zwischenspeichern einer potentiellen aktuellen Range:
```js
  const output = [];
  let currRange = [];
```

</Accordion>
<Accordion>
Dann der Loop durch die Zahlen des Input-Arrays:
```js
  for (let i = 0; i < nums.length; i++) {
    const currNum = nums[i];
    const nextNum = nums[i + 1] ?? Infinity;
```

Die aktuell und die n√§chste Zahl speichere ich mir der √úbersichtlichkeit halber jeweils in einer Variablen zwischen.

Sollte die n√§chste Zahl `null` oder `undefined`, also _nicht existent_ sein, setze ich sie auf Unendlich. Damit ist sie in jedem Fall ‚Äòpseudo‚Äô-gr√∂√üer als die aktuelle Zahl.

Da sie `0` sein kann und `0` <ExternalLink href={docs.glossary.falsy}>`falsy`</ExternalLink> ist, kann ich hier nicht einfach das <ExternalLink href={docs.operators.logicalOr}>`logische ODER (||)`</ExternalLink> verwenden, sondern verwende den <ExternalLink href={docs.operators.nullish}>`Nullish coalescing operator (??)`</ExternalLink>.

</Accordion>
<Accordion>
Dann berechnen wir den Abstand zwischen der aktuellen und der n√§chsten Zahl:
```js
    const distance = Math.abs(currNum - nextNum);
```

Den reinen Abstand zwischen den beiden Zahlen berechnen wir mit dem _Betrag_ ihrer Differenz ([`Math.abs()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/abs)). Wir streichen also quasi ein potentielles (negatives) Vorzeichen.

</Accordion>
<Accordion>
Dann pr√ºfen wir, ob der Abstand `1` ist:
```js
    if (distance === 1) {
      currRange.push(currNum);
      continue;
    }
```

Dann k√∂nnen wir die aktuelle Zahl an das Zwischenspeicher-Array anh√§ngen.

Mit <ExternalLink href={docs.statements.continue}>`continue`</ExternalLink> beenden wir die aktuelle Iteration und springen direkt zur n√§chsten Zahl. Ohne dass der restliche Code in der <ExternalLink href={docs.statements.for}>`For-Schleife`</ExternalLink> ausgef√ºhrt wird.

Ich bin ein gro√üer Fan dieses Keywords, denn so kann man sich jede Menge un√ºbersichtlicher if-else-Konstruktionen sparen. Mehr dazu findest du <ExternalLink href={docs.statements.continue}>hier</ExternalLink>.

</Accordion>
<Accordion>
Wenn der Abstand *nicht* `1` ist, pr√ºfen wir, ob unser Zwischenspeicher-Array gerade leer ist:
```js
    if (currRange.length) {
      currRange.push(currNum);
```

Wenn also beides zutrifft hie√üe das, dass die aktuelle Zahl auch die letzte Zahl der aktuellen Range ist. Die k√∂nnen wir auch noch ans aktuelle Zwischenspeicher-Array anh√§ngen.

</Accordion>
<Accordion>
Dann m√ºssen wir noch pr√ºfen, ob die aktuelle Range lang genug ist, um als Range definiert werden zu k√∂nnen:
```js
      if (currRange.length >= 3) output.push(currRange[0] + "-" + currNum);
```

Wenn ja, k√∂nnen wir die erste Zahl der Range und die letzte (also die aktuelle) verbunden mit einem `-` an unser Ergebnis-Array anh√§ngen.

</Accordion>
<Accordion>
Wenn nicht, h√§ngen wir nur die erste und die letzte Zahl ohne `-` an:
```js
      else output.push(currRange[0], currNum);
```

</Accordion>
<Accordion>
Nicht vergessen die aktuelle Range, also das Zwischenspeicher-Array zur√ºckzusetzen:
```js
      currRange = [];
      continue;
    }
```

</Accordion>
<Accordion>
Wenn der Abstand nicht `1` ist und auch das Zwischenspeicher-Array leer ist, h√§ngen wir unsere aktuelle Zahl schn√∂de an das Ergebnis-Array:
```js
    output.push(currNum);
  }
```

</Accordion>
<Accordion>
Nach dem Loop nur noch das Ergebnis-Array in einen String umwandeln und zur√ºckgeben:
```js
  return output.join(",");
}
```

</Accordion>
<Accordion>

Voil√°! üí™

[Fragen?](#feedback)

</Accordion>
</Accordion>

<Accordion>
**Komplettl√∂sung**

```js
function solution(nums) {
  const output = [];
  let currRange = [];

  for (let i = 0; i < nums.length; i++) {
    const currNum = nums[i];
    const nextNum = nums[i + 1] ?? Infinity;
    const distance = Math.abs(currNum - nextNum);

    if (distance === 1) {
      currRange.push(currNum);
      continue;
    }

    if (currRange.length) {
      currRange.push(currNum);

      if (currRange.length >= 3) output.push(currRange[0] + "-" + currNum);
      else output.push(currRange[0], currNum);

      currRange = [];
      continue;
    }

    output.push(currNum);
  }

  return output.join(",");
}
```

</Accordion>

## Feedback

<Accordion>
**Schreib mir!**

<SocialLinks
  emailSubject={`Frage zu ${apiData.platform} "${apiData.name}" (${codeChallengeData.language})`}
/>

</Accordion>
