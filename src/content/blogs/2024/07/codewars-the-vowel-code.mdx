---
title:
pubDate: 2024-05-03
description:
category: coden
tags:
  - codewars
  - typescript
series: code challenges
vgWortCode: 2e6eb19ddf134afa83670c555520ac16

codeChallengeData:
  platform: codewars
  id: 53697be005f803751e0015aa
  language: TypeScript
---

## Inhalt

1. [Die Fakten](#)
1. [Beschreibung](#)
1. [L√∂sung](#)
   1. [Pseudo-Code](#)
   1. [Code](#)
1. [Feedback](#)

---

## Die Fakten:

|                |                                                                                                                                            |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| **Plattform:** | <ExternalLink href={baseURLs[codeChallengeData['platform']]}>{domains[codeChallengeData['platform']]}</ExternalLink>                       |
| **Name:**      | <ExternalLink href={`${codeChallenge[codeChallengeData['platform']].challenge.url}/${codeChallengeData.id}`}>{apiData.name}</ExternalLink> |
| **Level**:     | {apiData.level}                                                                                                                            |
| **Sprache**:   | {codeChallengeData.language}                                                                                                               |

## Beschreibung:

<FetchedMarkdown>{apiData.description}</FetchedMarkdown>

Quelle: <ExternalLink href={baseURLs[codeChallengeData['platform']]}>{domains[codeChallengeData['platform']]}</ExternalLink>

## L√∂sung

### Pseudo-Code

Erst die L√∂sungsschritte in Pseudo-Code. Los geht‚Äôs:

<Accordion>
**L√∂sungsschritte**

<Accordion>
Schritt 1

Als Erstes k√ºmmern wir uns um die Encode-Funktion

</Accordion>
<Accordion>
Schritt 2

Hier brauchen wir einen Loop

</Accordion>
<Accordion>
Schritt 3

Es gibt viele M√∂glichkeiten, hier ist was mir eingefallen ist:

</Accordion>
<Accordion>
Schritt 4

F√ºr jeden Buchstaben im Input-String testen wir, ob er im String ‚Äúaeiou‚Äù vorhanden ist

</Accordion>
<Accordion>
Schritt 5

wenn ja, geben wir dessen Index im Vokal-String + 1 zur√ºck, sonst den Buchstaben

</Accordion>
<Accordion>
Schritt 6

F√ºr die Decode-Funktion m√ºssen wir den Loop leicht anpassen:

</Accordion>

<Accordion>
Schritt 7

Wenn das aktuelle Zeichen eine Zahl ist und ein Zeichen mit dieser Zahl minus 1 als Index im Vokal-String enthalten ist, geben wir genau dieses Zeichen/Vokal zur√ºck

</Accordion>

<Accordion>
Schritt 8

Ansonsten geben wir das aktuelle Zeichen unver√§ndert zur√ºck

Klingt komplizierter als es ist...

</Accordion>

</Accordion>

### Code

Geil. √úbersetzen wir unseren Pseudo-Code in {codeChallengeData.language}:

<Accordion>
**L√∂sungsschritte**

<Accordion>
Meine erste Zeile der Encode-Funktion (ich habe `string` in `str` umbenannt):

```ts
export function encode(str: string): string {
```

</Accordion>
<Accordion>
Den Rest kriege ich in eine Zeile:

```ts
  return [...str].map((char) => "aeiou".indexOf(char) + 1 || char).join("");
}
```

Da wir genauso viele Zeichen zur√ºckgeben wie reinkommen, schreit‚Äôs nach einem <ExternalLink href={docs.array.map}>`.map()`</ExternalLink>-Loop. Der Rest ist wie oben beschrieben, mit folgendem Trick:
Wenn `char` nicht in `‚Äùaeiou‚Äù` gefunden wird, gibt <ExternalLink href={docs.array.indexOf}>`.indexOf()`</ExternalLink> `-1` zur√ºck. Jetzt machen wir uns zunutze, dass wir sowieso den Index + 1 brauchen. Denn wenn wir `-1` zur√ºck bekommen und `+ 1` rechnen, bekommen wir `0`. `0` ist `falsy`. Damit wird der Code nach dem <ExternalLink href={docs.operators.logicalOr}>logischen Oder</ExternalLink> `||` ausgef√ºhrt und wir geben den unver√§nderten `char` zur√ºck. Sweet!

</Accordion>
<Accordion>
Weiter geht‚Äôs mit der Decode-Funktion:

Meine erste Zeile der Decode-Funktion (ich hab wieder `string` in `str` umbenannt):

```ts
export function decode(str: string): string {
```

</Accordion>
<Accordion>

Auch hier passt der Rest wieder in eine Zeile:

```ts
  return [...str].map((char) => "aeiou"[Number(char) - 1] || char).join("");
}
```

Das Prinzip ist √§hnlich. Nur hier pr√ºfen wir, ob `char` eine Zahl ist.
Wenn nicht, bekommen wir Murks (`NaN`) zur√ºck. Murks (`NaN`) ist `falsy` und damit wird in diesem Fall auch hier wieder einfach der Ausgangs-`char` zur√ºckgegeben.
Ist `char` eine Zahl, aber gr√∂√üer als die L√§nge von `‚Äúaeiou‚Äù` kriegen wir `undefined` zur√ºck. Ebenfalls `falsy` und wir springen wieder auf die rechte Seite des <ExternalLink href={docs.operators.logicalOr}>`logischen Oders`</ExternalLink>.
Wenn `char` eine Zahl kleiner oder gleich der L√§nge des Vokal-Strings ist, z.B. `3`, wird aus dem Ausdruck in der eckigen Klammer ein Zahl. Hier z.B. `2` (`3` - `1`). Also haben wir dann `‚Äúaeiou‚Äù[2]`. Es wird also das Zeichen mit dem Index `2`, hier der Vokal `i`, zur√ºckgegeben.

B√§√§m! üí™

[Fragen?](#feedback)

</Accordion>
</Accordion>

<Accordion>
**Komplettl√∂sung**

```ts
export function encode(str: string): string {
  return [...str].map((char) => "aeiou".indexOf(char) + 1 || char).join("");
}

export function decode(str: string): string {
  return [...str].map((char) => "aeiou"[Number(char) - 1] || char).join("");
}
```

</Accordion>

## Feedback

<Accordion>
**Schreib mir!**

<SocialLinks
  emailSubject={`Frage zu ${apiData.platform} "${apiData.name}" (${codeChallengeData.language})`}
/>

</Accordion>
