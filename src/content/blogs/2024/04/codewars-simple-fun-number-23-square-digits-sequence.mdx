---
title:
pubDate: 2024-04-12
description:
category: coden
tags:
series: code challenges
vgWortCode: 3fe0b4f6d4c345bc95c37b59da0a81b2

codeChallengeData:
  platform: codewars
  id: 5886d65e427c27afeb0000c1
  language: TypeScript
---

## Inhalt

1. [Die Fakten](#)
1. [Beschreibung](#)
1. [L√∂sung](#)
   1. [Pseudo-Code](#)
   1. [Code](#)
1. [Feedback](#)

---

## Die Fakten:

|                |                                                                                                                                            |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| **Plattform:** | <ExternalLink href={baseURLs[codeChallengeData['platform']]}>{domains[codeChallengeData['platform']]}</ExternalLink>                       |
| **Name:**      | <ExternalLink href={`${codeChallenge[codeChallengeData['platform']].challenge.url}/${codeChallengeData.id}`}>{apiData.name}</ExternalLink> |
| **Level**:     | {apiData.level}                                                                                                                            |
| **Sprache**:   | {codeChallengeData.language}                                                                                                               |

## Beschreibung:

<FetchedMarkdown>{apiData.description}</FetchedMarkdown>

Quelle: <ExternalLink href={baseURLs[codeChallengeData['platform']]}>{domains[codeChallengeData['platform']]}</ExternalLink>

## L√∂sung

### Pseudo-Code

Wie immer gibt's reichlich Varianten, hier ist eine meiner.

Erst die L√∂sungsschritte in Pseudo-Code. Los geht‚Äôs:

<Accordion>
**L√∂sungsschritte**

<Accordion>
Schritt 1

Als Erstes k√∂nnen wir uns 2 Hilfsfunktionen basteln, eine, die Zahlen in ihre Ziffern zerlegt und eine, die diese Ziffern aufsummiert.

</Accordion>
<Accordion>
Schritt 2

Dann k√∂nnen wir uns um die Hauptfunktion k√ºmmern.

</Accordion>
<Accordion>
Schritt 3

Dort k√∂nnen wir zuerst ein Ergebnis-Array anlegen und schon mal die Input-Zahl rein tun.

</Accordion>
<Accordion>
Schritt 4

Dann wird geloopt bis der Arzt kommt oder wir auf eine Summe sto√üen, die bereits im Ergebnis-Array enthalten ist.

</Accordion>
<Accordion>
Schritt 5

Wenn das so ist, geben wir die L√§nge des Ergebnis-Arrays + 1 zur√ºck.

</Accordion>
<Accordion>
Schritt 6

Ansonsten f√ºgen wir die aktuelle quadrierte Ziffernsumme zum Ergebnis-Array hinzu.

</Accordion>
</Accordion>

### Code

Geil. √úbersetzen wir unseren Pseudo-Code in {codeChallengeData.language}:

<Accordion>
**L√∂sungsschritte**

<Accordion>
Die erste Zeile meines Verzifferungs-Helferleins:

```ts
function digitize(num: number): number[] {
```

</Accordion>
<Accordion>

Was kommt jetzt? Ah, die Logik! Logisch oder?!:

```ts
  return [...num.toString()].map(Number);
}
```

Hier wird einfach die Input-Zahl erst in einen String und dann in ein Array umgewandelt. Mit [.map(Number)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#using_parseint_with_map) werden dann die String-Zahlen wieder in Zahlen umgewandelt.

Dann die Hilfsfunktion zum Aufsummieren der Ziffern.

</Accordion>
<Accordion>

Die erste Zeile der Hilfsfunktion zum Aufsummieren der Ziffern:

```ts
function sumUpSquaredDigits(num: number): number {
```

</Accordion>
<Accordion>

Hier die Logik:

```ts
  return digitize(num).reduce((sum, digit) => sum + digit ** 2, 0);
}
```

Hier k√∂nnen wir unsere erste Hilfsfunktion anwenden um die Input-Zahl in ein Array aus Ziffern zu verwandeln. Dann k√∂nnen wir mit <ExternalLink href={docs.array.reduce}>`.reduce()`</ExternalLink> jede Ziffer quadrieren und zur Summe addieren, die wir dann zur√ºckgeben. Die `0` am Ende hei√üt, dass wir bei `0` anfangen.

Dann kann es endlich losgehen mit der Hauptfunktion:

</Accordion>
<Accordion>

Die erste Zeile meiner Hauptfunktion (ich habe `a` in `num` umbenannt):

```ts
export function squareDigitsSequence(num: number): number {
```

</Accordion>
<Accordion>

Als Erstes erstelle ich mir mein Ergebnis-Array und packe direkt `num` als erstes Element rein:

```ts
const results = [num];
```

</Accordion>
<Accordion>

Dann der Loop:

```ts
  while (true) {
```

Dieser Loop ist unendlich. Wir m√ºssen also dran denken, ihn irgendwann zu beenden.

</Accordion>
<Accordion>

F√ºr jeden Durchlauf erstelle ich mir 2 Variablen:

```ts
const curr = results[0];
const squaredDigitsSum = sumUpSquaredDigits(curr);
```

Als aktuelles Element w√§hle ich hier das erste. Du kannst hier gerne auch immer das letzte nehmen.

</Accordion>
<Accordion>

Wir loopen solange, bis wir auf eine Zahl sto√üen, die bereits im Ergebnis-Array vorhanden ist:

```ts
if (results.includes(squaredDigitsSum)) return results.length + 1;
```

Wenn das der Fall ist, beenden wir Loop und Funktion mit `return`. Wir geben die aktuelle L√§nge des Arrays plus dem einen Element mit der aktuellen Summe zur√ºck.

</Accordion>
<Accordion>

Wenn nicht, h√§ngen wir die aktuelle Summe an das Ergebnis-Array dran:

```ts
    results.unshift(squaredDigitsSum);
  }
}
```

Da wir oben das erste Element als unser aktuelles gew√§hlt haben, h√§ngen wir es hier VORNE an. Wenn du das letzte genommen hast, musst du es HINTEN anf√ºgen.

</Accordion>
<Accordion>

Voil√°! üí™

[Fragen?](#feedback)

</Accordion>
</Accordion>

<Accordion>
**Komplettl√∂sung**

```ts
export function squareDigitsSequence(num: number): number {
  const results = [num];

  while (true) {
    const curr = results[0];
    const squaredDigitsSum = sumUpSquaredDigits(curr);

    if (results.includes(squaredDigitsSum)) return results.length + 1;

    results.unshift(squaredDigitsSum);
  }
}

function digitize(num: number): number[] {
  return [...num.toString()].map(Number);
}

function sumUpSquaredDigits(num: number): number {
  return digitize(num).reduce((sum, digit) => sum + digit ** 2, 0);
}
```

</Accordion>

## Feedback

<Accordion>
**Schreib mir!**

<SocialLinks
  emailSubject={`Frage zu ${apiData.platform} "${apiData.name}" (${codeChallengeData.language})`}
/>

</Accordion>
