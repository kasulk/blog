---
title:
pubDate: 2024-09-02
description:
category: coden
tags:
series: code challenges
vgWortCode: 7bcb2bfa386a41a08c8f42013301ee01

codeChallengeData:
  platform: codewars
  id: 5ca24526b534ce0018a137b5
  language: TypeScript
---

## Inhalt

1. [Die Fakten](#)
1. [Beschreibung](#)
1. [L√∂sung](#)
   1. [Pseudo-Code](#)
   1. [Code](#)
1. [Feedback](#)

---

## Die Fakten:

|                |                                                                                                                                            |
| -------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| **Plattform:** | <ExternalLink href={baseURLs[codeChallengeData['platform']]}>{domains[codeChallengeData['platform']]}</ExternalLink>                       |
| **Name:**      | <ExternalLink href={`${codeChallenge[codeChallengeData['platform']].challenge.url}/${codeChallengeData.id}`}>{apiData.name}</ExternalLink> |
| **Level**:     | {apiData.level}                                                                                                                            |
| **Sprache**:   | {codeChallengeData.language}                                                                                                               |

## Beschreibung:

<FetchedMarkdown>{apiData.description}</FetchedMarkdown>

Quelle: <ExternalLink href={baseURLs[codeChallengeData['platform']]}>{domains[codeChallengeData['platform']]}</ExternalLink>

## L√∂sung

### Pseudo-Code

Wie immer gibt's reichlich Varianten, hier ist eine meiner.

Erst die L√∂sungsschritte in Pseudo-Code. Los geht‚Äôs:

<Accordion>
**L√∂sungsschritte**

<Accordion>
Schritt 1

Zuerst brauchen wir ein paar Variablen. Eine f√ºr‚Äôs gesamte Keypad, eine um den aktuellen Klein-/Gro√üschreibmodus festzuhalten und eine um uns den letzten gedr√ºckten Button zu merken.

</Accordion>
<Accordion>
Schritt 2

Dann loopen wir durch den Input-String.

</Accordion>
<Accordion>
Schritt 3

Wir suchen das jeweils aktuelle Zeichen in unserem Keypad, darum gehen wir mit einem weiteren Loop durch jeden Button im Keypad.

</Accordion>
<Accordion>
Schritt 4

Und pr√ºfen, ob unser aktuelles Zeichen auf dem aktuellen Button ist.

</Accordion>
<Accordion>
Schritt 5

Wenn ja, speichern wir uns den Index, den das Zeichen auf dem Button hat.

</Accordion>
<Accordion>
Schritt 6

Wenn der aktuelle Button der gleiche ist, wie der letzte, f√ºgen wir schon mal ein Leerzeichen zum aktuellen Button-Zwischenergebnis hinzu.

</Accordion>
<Accordion>
Schritt 7

Wenn sich das aktuelle Zeichen in der oberen Reihe des Buttons befindet (also z.B. eine Zahl ist), setzen wir den letzten Button zur√ºck und f√ºgen den aktuellen Button, gefolgt von einem `-` zum aktuellen Button-Zwischenergebnis hinzu. In diesem Fall k√∂nnen wir das Zwischenergebnis speichern und zum n√§chsten Element springen.

</Accordion>
<Accordion>
Schritt 8

Wenn das aktuelle Zeichen ein Kleinbuchstabe ist `UND` wir uns im Gro√übuchstaben-Modus befinden `ODER` ein Gro√übuchstabe ist `UND` wir uns `NICHT` im Gro√übuchstabenmodus befinden, switchen wir den Gro√übuchstabenmodus ins Gegenteil und f√ºgen ein `#` zum aktuellen Button-Zwischenergebnis hinzu.

</Accordion>
<Accordion>
Schritt 9

Am Ende des inneren Loops h√§ngen wir noch den Button so oft ans aktuelle Button-Zwischenergebnis an, wie der Index des aktuellen Zeichens auf dem Button (also bei einem `h`, mit Index `2` auf dem Button `4`: `2x4 ‚Üí 44`).

</Accordion>
<Accordion>
Schritt 10

Nicht vergessen den letzten Button f√ºr die n√§chste Runde auf den aktuellen zu setzen.

</Accordion>
<Accordion>
Schritt 11

Nach dem inneren Loop speichern wir das aktuelle Button-Zwischenergebnis.

</Accordion>
<Accordion>
Schritt 12

Nach dem √§u√üeren Loop geben wir das Endergebnis als String zur√ºck.

Puh, ganz sch√∂n komplex... Aber ich hab dich gewarnt!

</Accordion>
</Accordion>

### Code

Geil. √úbersetzen wir unseren Pseudo-Code in {codeChallengeData.language}:

<Accordion>
**L√∂sungsschritte**

<Accordion>
Der Lesbarkeit halber erstelle ich mir 2 Hilfsfunktionen:

```ts
function isLowerCaseLetter(char: string): boolean {
  return /[a-z]/.test(char);
}

function isUpperCaseLetter(char: string): boolean {
  return /[A-Z]/.test(char);
}
```

Dann geht‚Äôs los mit der Hauptfunktion!

</Accordion>
<Accordion>

Die erste Zeile meiner Hauptfunktion:

```ts
export function sendMessage(message: string): string {
```

</Accordion>
<Accordion>

Dann erstellen wir unsere Variablen:

```ts
const keypad = [
  "1.,?!",
  "2abc",
  "3def",
  "4ghi",
  "5jkl",
  "6mno",
  "7pqrs",
  "8tuv",
  "9wxyz",
  "*'-+=",
  "0 ",
  "#",
];

let isUpperCaseMode = false;
let lastButton = "";
```

</Accordion>
<Accordion>

Dann loopen wir durch den Input-String:

```ts
  return [...message]
    .map((char) => {
      let currResult = "";
```

Daf√ºr wandeln wir den String als Erstes in ein Array um. Da wir f√ºr jedes Zeichen im Input-String etwas zur√ºck haben wollen, bietet sich hier ein <ExternalLink href={docs.array.map}>`.map()`</ExternalLink> an.

Und da das Array, das wir danach erhalten (fast) schon unserem Endergebnis entspricht, k√∂nnen wir unser `return`-Statement schon hier platzieren.

Au√üerdem brauchen wir noch eine Variable um unsere Zwischenergebnisse f√ºr das jeweils aktuelle Zeichen zu speichern.

</Accordion>
<Accordion>

Dann der (innere) Loop durch die Keypad-Buttons:

```ts
      for (const button of keypad) {
```

Hier entscheide ich mich f√ºr einen <ExternalLink href={docs.statements.forOf}>`for...of`</ExternalLink>-Loop, damit wir ihn ggf. vorzeitig beenden k√∂nnen.

</Accordion>
<Accordion>

Wir checken jeden Button, ob er unser aktuelles Zeichen enth√§lt:

```ts
        if (button.includes(char.toLowerCase())) {
```

</Accordion>
<Accordion>

Wenn ja, speichern wir uns den Index des Zeichens im Button in einer Variablen:

```ts
const currButton = button[0];
const keyIndex = button.indexOf(char.toLowerCase());
const isTopRow = !keyIndex;
```

Au√üerdem erstelle ich mir ein paar weitere (optionale) Variablen zur besseren Lesbarkeit.

Sollte der `keyIndex` `0` sein, ist unser gesuchtes Zeichen das erste auf dem Button. Also das Zeichen in der oberen Reihe. Da `0` <ExternalLink href={docs.glossary.falsy}>`falsy`</ExternalLink> ist, gibt `!keyIndex` `true` zur√ºck. In allen anderen F√§llen `false`.

</Accordion>
<Accordion>

Dann pr√ºfen wir, ob der aktuelle Button der selbe ist wie der letzte:

```ts
if (currButton === lastButton) currResult += " ";
```

Wenn ja, f√ºgen wir das Leerzeichen zu unserem aktuellen Zwischenergebnis hinzu.

</Accordion>
<Accordion>

Dann pr√ºfen wir, ob sich unser Zeichen in der oberen Reihe befindet (also z.B. eine Zahl ist):

```ts
if (isTopRow) {
  lastButton = "";
  return currResult + currButton + "-";
}
```

Wenn ja, k√∂nnen wir den inneren Loop beenden und f√ºr das aktuelle Zeichen im Input-String unser bisheriges Zwischenergebnis plus den aktuellen Button und ein `-` zur√ºckgeben.

Da es laut Regel f√ºr das Halten eines Buttons der letzte Button keine Rolle spielt, setzen wir ihn vorher noch zur√ºck.

</Accordion>
<Accordion>

Jetzt k√∂nnen wir pr√ºfen, ob das aktuelle Zeichen ein Kleinbuchstabe ist `UND` der UpperCaseMode gerade aktiv ist `ODER` ob es ein Gro√übuchstabe ist `UND` der UpperCaseMode gerade `NICHT` aktiv ist:

```ts
          if (
            (isLowerCaseLetter(char) && isUpperCaseMode) ||
            (isUpperCaseLetter(char) && !isUpperCaseMode)
          ) {
```

</Accordion>
<Accordion>

Wenn eines von beiden zutrifft, m√ºssen wir den aktuellen UpperCaseMode in sein Gegenteil switchen:

```ts
            isUpperCaseMode = !isUpperCaseMode;
            currResult = "#";
          }
```

Au√üerdem ersetzen wir dann unser bisheriges Zwischenergebnis mit einem `#`.

</Accordion>
<Accordion>

Dann erg√§nzen wir den aktuellen Button in entsprechender Anzahl zum Zwischenergebnis:

```ts
currResult += currButton.repeat(keyIndex);
```

Die Anzahl der Wiederholungen ergibt sich aus der Position, also dem Index, auf dem Button.

</Accordion>
<Accordion>

Am Ende des inneren Loops nicht vergessen, den letzten Button zu aktualisieren:

```ts
          lastButton = currButton;
        }
      }
```

</Accordion>
<Accordion>

Am Ende des √§u√üeren Loops noch das aktuelle Zwischenergnis zur√ºckgeben:

```ts
      return currResult;
    })
```

</Accordion>
<Accordion>

Und zum Schluss noch das Endergebnis-Array in einen String umwandeln:

```ts
    .join("");
}
```

Zur√ºckgegeben haben wir das Ganze schon oben mit dem `return`-Statement vor dem <ExternalLink href={docs.array.map}>`.map()`</ExternalLink>-Loop.

</Accordion>
<Accordion>

Voil√°! üí™

Wie gesagt, dat Ding war ziemlich komplex und eher etwas anspruchsvoller als ein Level 6. Aber: Nur die Harten komm‚Äô in‚Äô Garten!

[Fragen?](#feedback)

</Accordion>
</Accordion>

<Accordion>
**Komplettl√∂sung**

```ts
export function sendMessage(message: string): string {
  const keypad = [
    "1.,?!",
    "2abc",
    "3def",
    "4ghi",
    "5jkl",
    "6mno",
    "7pqrs",
    "8tuv",
    "9wxyz",
    "*'-+=",
    "0 ",
    "#",
  ];

  let isUpperCaseMode = false;
  let lastButton = "";

  return [...message]
    .map((char) => {
      let currResult = "";

      for (const button of keypad) {
        if (button.includes(char.toLowerCase())) {
          const currButton = button[0];
          const keyIndex = button.indexOf(char.toLowerCase());
          const isTopRow = !keyIndex;

          if (currButton === lastButton) currResult += " ";

          if (isTopRow) {
            lastButton = "";
            return currResult + currButton + "-";
          }

          if (
            (isLowerCaseLetter(char) && isUpperCaseMode) ||
            (isUpperCaseLetter(char) && !isUpperCaseMode)
          ) {
            isUpperCaseMode = !isUpperCaseMode;
            currResult = "#";
          }

          currResult += currButton.repeat(keyIndex);
          lastButton = currButton;
        }
      }

      return currResult;
    })
    .join("");
}

function isLowerCaseLetter(char: string): boolean {
  return /[a-z]/.test(char);
}

function isUpperCaseLetter(char: string): boolean {
  return /[A-Z]/.test(char);
}
```

</Accordion>

## Feedback

<Accordion>
**Schreib mir!**

<SocialLinks
  emailSubject={`Frage zu ${apiData.platform} "${apiData.name}" (${codeChallengeData.language})`}
/>

</Accordion>
